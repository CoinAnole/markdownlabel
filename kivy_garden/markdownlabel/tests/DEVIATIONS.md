## test_import.py

- Line 9: Class name `TestMarkdownLabelImport` does not follow "one class per property/behavior" guideline. The class contains tests for both import functionality AND text property behavior. These should be separated into two distinct classes (e.g., `TestMarkdownLabelImport` for import tests and `TestTextProperty` for text property tests).
- Line 12-16: Test method `test_markdownlabel_import` name does not accurately reflect what it asserts. The method asserts that the label has a 'text' attribute using `hasattr`, but the name suggests it only tests import functionality. A more accurate name would be `test_markdownlabel_has_text_property` or `test_imported_markdownlabel_has_text_attribute`.
- Line 18-22: Test method `test_markdownlabel_text_property` name could be more precise. The method asserts text assignment (`label.text == '# Hello'`), not just the existence of the property. A more descriptive name would be `test_text_property_assignment` or `test_text_property_accepts_value`.
- Line 12-22: No use of property-based testing with Hypothesis strategies from test_utils.py. The guidelines encourage using property-based testing with strategies like `st_alphanumeric_text` for more comprehensive testing.
- Line 12-22: No max_examples comments present (not applicable as there is no property-based testing, but worth noting as a deviation from the encouraged testing approach).

## test_inline_renderer.py

- Line 15-73: Custom strategies (`text_token`, `strong_token`, `emphasis_token`, `codespan_token`, `strikethrough_token`, `link_token`) are defined in the test file instead of in `test_utils.py`. The guidelines state: "When adding new helper functions: 1. **Add to `test_utils.py`** - Never duplicate in individual test files" and "Always use helper functions from `test_utils.py` instead of duplicating code."
- Line 84, 96, 108, 118, 129, 147, 173, 207, 229, 413, 678, 764: All property-based tests use identical max_examples=20 with the same comment "Complex strategy: 20 examples (adequate coverage)". The guidelines provide specific classifications with different max_examples values for different strategy types (Boolean: 2, Small finite: input space size, Medium finite: 20-50 based on input space, Combination: product capped at 50, Complex: 10-50 based on complexity). These tests should be classified according to their actual strategy type rather than all using the same generic classification.
- Line 205-207: Strategy `st.text(alphabet='[]&', min_size=1, max_size=50)` is incorrectly classified as "Medium finite strategy: 50 examples (adequate finite coverage)". This is a complex/infinite strategy (3^50 possible combinations), not a finite strategy. The classification should be "Complex strategy" with an appropriate rationale.
- Line 401-411: The `st.one_of` strategy combining multiple text generation patterns is classified as "Complex strategy: 20 examples (adequate coverage)" but this is actually a combination strategy that should use the "Combination strategy" classification with rationale about sampling from multiple URL patterns.
- Line 657-676: The `st.one_of` strategy combining multiple HTML generation patterns is classified as "Complex strategy: 20 examples (adequate coverage)" but this is actually a combination strategy that should use the "Combination strategy" classification with rationale about sampling from multiple HTML patterns.
- Line 760-762: The strategy `st.text(min_size=0, max_size=200, alphabet=st.characters(whitelist_categories=['L', 'N', 'P', 'S', 'Z']))` is classified as "Complex strategy: 20 examples (adequate coverage)" but with a large max_size of 200, this could be considered a more complex strategy that might benefit from a different max_examples value or classification.

## test_kivy_renderer.py

- Line 38-40: Strategy `st.integers(min_value=1, max_value=5)` is classified as "Small finite strategy: 5 examples (input space size: 5)" but the heading level range is actually 1-6 (6 values), not 1-5. The test should use `min_value=1, max_value=6` with max_examples=6, or the classification should be updated to reflect the actual input space size of 5.
- Line 83-85: Strategy combining `st.integers(min_value=1, max_value=6)` (6 values) and `st.floats(min_value=10, max_value=30)` (infinite range) is classified as "Combination strategy: 10 examples (performance optimized)". This is a mixed finite/infinite strategy. The classification should be "Complex strategy" with rationale about testing heading levels with various base font sizes, as it combines a finite set with an infinite continuous range.
- Line 776-1083: Class `TestKivyRendererEdgeCases` contains tests for various edge cases and internal methods. While the class name is descriptive, it mixes multiple different behaviors (image callbacks, code block background updates, block quote border updates, table internals, deep nesting, unknown tokens, list items, text size binding, blank lines) in a single class. According to the guideline "One class per property or behavior", these should potentially be split into separate classes like `TestImageTextureCallback`, `TestCodeBlockBackgroundUpdate`, `TestBlockQuoteBorderUpdate`, `TestTableInternalMethods`, `TestDeepNestingTruncation`, `TestUnknownTokenHandling`, `TestListItemRendering`, `TestTextSizeBinding`, `TestBlankLineRendering`.
- Line 997-1011: Test method `test_deep_nesting_truncation` in `TestKivyRendererEdgeCases` duplicates functionality already tested in `TestDeepNestingTruncation` class (lines 682-769). The earlier class has comprehensive tests for truncation behavior including `test_truncation_placeholder_when_nesting_exceeds_max`, `test_truncation_placeholder_text_format`, `test_truncation_placeholder_styling`, and `test_normal_nesting_does_not_truncate`. This duplicate test should be removed to avoid redundancy.
- Line 20-28: The test file correctly imports helper functions from `test_utils.py` including `heading_token`, `paragraph_token`, `list_token`, `code_block_token`, `block_quote_token`, `image_token`, and `table_token`. This follows the guideline to use shared helper functions instead of duplicating code.
- Line 63-82, 111-131, 141-204, 264-294, 296-308, 351-383, 424-455, 548-568, 662-673: All property-based tests using custom strategies from test_utils.py are correctly classified with appropriate max_examples values and standardized comments. This is compliant.
- Line 329-342, 576-591, 646-660: Tests using `@pytest.mark.parametrize` for small finite enumerations (6 languages, 3 alignments, 3 invalid alignments) are appropriate according to the guidelines which state "Single dimension, small set: Use `@pytest.mark.parametrize`" for enumerations ≤10 values. These are compliant.
- Line 391-416, 1050-1083: Unit tests for thematic break rendering, text size binding, and blank line rendering are appropriate as unit tests and follow the guidelines.
- Line 35-103, 108-131, 138-204, 209-254, 261-308, 312-343, 348-383, 388-416, 421-455, 460-568, 573-674, 679-769: Most test classes follow the "one class per property/behavior" guideline with descriptive names and related test methods grouped together. This is compliant.
- Line 1-1083: Overall, the test file follows most testing guidelines well, with good use of shared helper functions, appropriate test naming conventions, and proper property-based testing optimization. The main deviations are the mixed edge cases class and one duplicate test.

## test_core_functionality.py

- Line 111-126: Test method `test_text_change_updates_widgets` name does not accurately reflect what it asserts. The method asserts that the label's text property reflects the new value (not that widgets were updated/rebuilt), but the name suggests it tests widget updates. A more accurate name would be `test_text_change_updates_text_property` or `test_text_property_updates_on_change`.
- Line 178-195: Test method `test_ast_updates_with_text` name does not accurately reflect what it asserts. The method only asserts that `label.text == text2` (the text property was updated), not that the AST was updated. The AST is collected but never compared or asserted against. A more accurate name would be `test_text_property_updates_on_change` or the test should be updated to actually verify AST updates.
- Line 111-195: Tests in `TestMarkdownTextPropertyUpdates` class do not use rebuild contract testing helpers from test_utils.py. The guidelines provide helper functions like `collect_widget_ids()`, `assert_rebuild_occurred()`, and `assert_no_rebuild()` for testing rebuild behavior. These tests manually check child counts or text properties instead of using the standardized rebuild testing helpers.
- Line 217-226: Test method `test_link_produces_ref_markup` manually iterates through children to find Labels with ref markup, duplicating traversal logic. The guidelines provide `find_labels_recursive()` helper from test_utils.py for finding all Label widgets in the tree. This test should use the shared helper instead of manual iteration.
- Line 239-246: Test method `test_link_url_in_ref_tag` manually iterates through children to find Labels with ref markup, duplicating traversal logic. The guidelines provide `find_labels_recursive()` helper from test_utils.py for finding all Label widgets in the tree. This test should use the shared helper instead of manual iteration.
- Line 262-269: Test method `test_various_urls_in_links` manually iterates through children to find Labels with ref markup, duplicating traversal logic. The guidelines provide `find_labels_recursive()` helper from test_utils.py for finding all Label widgets in the tree. This test should use the shared helper instead of manual iteration.
- Line 77-90: Test method `test_multiple_blocks_produce_multiple_widgets` uses `st.integers(min_value=1, max_value=5)` which is correctly classified as "Small finite strategy: 5 examples (input space size: 5)". However, the test creates markdown with `num_blocks` paragraphs where `num_blocks` ranges from 1-5, which is a small finite input space. This is compliant.
- Line 129-153: Test method `test_different_block_counts_update_correctly` uses `st.integers(min_value=1, max_value=3)` for both parameters, which is correctly classified as "Combination strategy: 9 examples (combination coverage)". The test uses `force_rebuild()` appropriately for testing text property changes that trigger deferred rebuilds. This is compliant.
- Line 28-98: Class `TestMarkdownToWidgetTreeGeneration` follows the "one class per property/behavior" guideline with descriptive class name and related test methods grouped together. This is compliant.
- Line 104-196: Class `TestMarkdownTextPropertyUpdates` follows the "one class per property/behavior" guideline with descriptive class name and related test methods grouped together. This is compliant.
- Line 201-270: Class `TestMarkdownLinkRendering` follows the "one class per property/behavior" guideline with descriptive class name and related test methods grouped together. This is compliant.
- Line 275-398: Class `TestMarkdownNestingStability` follows the "one class per property/behavior" guideline with descriptive class name and related test methods grouped together. This is compliant.
- Line 33-34, 47-48, 65-66, 78-79, 109-110, 130-131, 157-158, 176-177, 206-207, 229-230, 250-251, 280-281, 299-300, 317-318: All property-based tests have standardized comments following the format `# [Strategy Type] strategy: [N] examples ([Rationale])`. This is compliant.
- Line 15-21: The test file correctly imports helper functions from `test_utils.py` including `markdown_heading`, `markdown_paragraph`, `markdown_link`, `simple_markdown_document`, and `st_alphanumeric_text`. This follows the guideline to use shared helper functions instead of duplicating code.
- Line 145-147, 167-169, 186-188: Tests correctly use `force_rebuild()` after text property changes to ensure immediate synchronous updates for deterministic testing. This follows the rebuild contract testing guidelines.

## test_label_compatibility.py

No deviations found.

## test_font_properties.py

- Line 27: Custom strategy `line_height_strategy` defined in test file instead of in `test_utils.py`. The guidelines state: "When adding new helper functions: 1. **Add to `test_utils.py`** - Never duplicate in individual test files" and "Always use helper functions from `test_utils.py` instead of duplicating code."
- Line 111: Test method `test_font_name_property_forwarding_triggers_rebuild` name does not accurately reflect what it asserts. The method manually calls `label.force_rebuild()` and then checks widget IDs, rather than testing that the property change naturally triggers a rebuild. The guidelines state: "Test method names should **accurately reflect what they assert**" and provide rebuild testing helpers like `assert_rebuild_occurred()` and `assert_no_rebuild()` for this purpose.
- Line 125: Manual `force_rebuild()` call in rebuild test instead of using `assert_rebuild_occurred()` or `assert_no_rebuild()` helpers from `test_utils.py`. The guidelines provide these helper functions for rebuild contract testing: "Use these helper functions from `test_utils.py`: `def assert_rebuild_occurred(widget, change_func):` and `def assert_no_rebuild(widget, change_func):`"
- Line 226: Test method `test_line_height_change_triggers_rebuild` name does not accurately reflect what it asserts. The method manually calls `label.force_rebuild()` and then checks widget IDs, rather than testing that the property change naturally triggers a rebuild. The guidelines state: "Test method names should **accurately reflect what they assert**."
- Line 242: Manual `force_rebuild()` call in rebuild test instead of using `assert_rebuild_occurred()` or `assert_no_rebuild()` helpers from `test_utils.py`. The guidelines provide these helper functions for rebuild contract testing.
- Lines 319-337: Custom helper method `_find_code_block_labels` defined in test class instead of in `test_utils.py`. The guidelines state: "When adding new helper functions: 1. **Add to `test_utils.py`** - Never duplicate in individual test files."
- Lines 339-343: Custom helper method `_find_non_code_labels` defined in test class instead of in `test_utils.py`. The guidelines state: "When adding new helper functions: 1. **Add to `test_utils.py`** - Never duplicate in individual test files."
- Lines 529-542: Custom helper function `collect_labels_and_scales` defined inline in test method instead of in `test_utils.py`. The guidelines state: "When adding new helper functions: 1. **Add to `test_utils.py`** - Never duplicate in individual test files."
- Lines 578-583, 616-620, 652-657, 698-702, 742-747, 826-831: Manual widget traversal to find heading/paragraph labels instead of using shared helper functions from `test_utils.py`. The guidelines provide `find_labels_recursive(widget)` for finding all Label widgets in the tree.
- Lines 111-135, 226-252: Rebuild tests manually collect and compare widget IDs using `collect_widget_ids()` and direct comparison instead of using `assert_rebuild_occurred()` or `assert_no_rebuild()` helpers from `test_utils.py`. The guidelines provide these helper functions for rebuild contract testing.
- Lines 789-810, 820-853, 863-883, 891-921: Tests in `TestNoRebuildOnFontSizeChange` class manually check widget IDs instead of using `assert_no_rebuild()` helper from `test_utils.py`. The guidelines provide this helper function for verifying no rebuild occurred.
- Line 818: Strategy `st.integers(min_value=1, max_value=6)` is classified as "Small finite strategy: 6 examples (input space size: 6)" which is correct and compliant with the guidelines.
- Lines 172-175, 188-191, 204-207, 254-257, 271-274, 288-291, 346-348, 363-366, 382-385, 401-404, 437-440, 456-462, 512-519, 562-569, 577-580, 604-609, 639-645, 676-687, 728-735, 781-788, 812-819, 855-862, 885-890: All property-based tests have standardized comments following the format `# [Strategy Type] strategy: [N] examples ([Rationale])`. This is compliant.
- Lines 34-164, 169-305, 311-503, 509-630, 636-772, 778-923: All test classes follow the "one class per property/behavior" guideline with descriptive class names and related test methods grouped together. This is compliant.
- Lines 15-23: The test file correctly imports helper functions from `test_utils.py` including `KIVY_FONTS`, `simple_markdown_document`, `find_labels_recursive`, `floats_equal`, `collect_widget_ids`, `st_alphanumeric_text`, and `st_font_size`. This follows the guideline to use shared helper functions instead of duplicating code.

## test_color_properties.py

- Line 24-180: Class `TestColorPropertyForwarding` contains tests for multiple distinct color-related behaviors (color property forwarding to paragraphs, headings, list items, tables; code block color preservation; mixed content color separation; link styling). According to the guideline "One class per property or behavior", these should potentially be split into separate classes like `TestColorPropertyForwarding`, `TestCodeBlockColorPreservation`, `TestMixedContentColorSeparation`, and `TestLinkColorStyling` for better organization and clarity.
- Line 82-100: Test method `test_color_change_updates_value` verifies that color changes update the value on existing widgets, but does not verify that the widget tree is preserved (no rebuild occurs). According to the rebuild contract testing guidelines, style-only properties like `color` should be tested to verify they preserve the widget tree. A complementary test like `test_color_change_preserves_widget_tree` should be added that uses `collect_widget_ids()` to verify no rebuild occurs when color changes.

## test_text_properties.py

- Line 259-277, 435-461, 577-603: Rebuild tests manually collect and compare widget IDs using `collect_widget_ids()` and direct comparison instead of using `assert_rebuild_occurred()` or `assert_no_rebuild()` helpers from `test_utils.py`. The guidelines provide these helper functions for rebuild contract testing: "Use these helper functions from `test_utils.py`: `def assert_rebuild_occurred(widget, change_func):` and `def assert_no_rebuild(widget, change_func):`". The tests `test_text_size_height_change_updates_labels`, `test_unicode_errors_change_triggers_rebuild`, and `test_strip_change_triggers_rebuild` should use these helpers instead of manual ID collection and comparison.

## test_padding_properties.py

No deviations found.

## test_sizing_behavior.py

- Line 515-529: Test method `test_strict_mode_updates_value` name does not accurately reflect what it asserts. The method name suggests it tests value updates, but the actual assertion only checks that `len(label.children) >= 1` after toggling `strict_label_mode`. The method does not verify that the value was updated or that a rebuild occurred. A more accurate name would be `test_strict_mode_toggle_preserves_children_count` or `test_strict_mode_toggle_maintains_widget_tree`.
- Line 515-529: The test method `test_strict_mode_updates_value` does not properly test rebuild contract behavior. According to the rebuild contract testing guidelines, tests that verify rebuild behavior should use helper functions like `assert_rebuild_occurred()` or `assert_no_rebuild()` from `test_utils.py`, or should use `collect_widget_ids()` to compare widget IDs before and after the change. The current test only checks child count without verifying widget identity preservation or rebuild occurrence.
- Line 207-314, 320-555: The test file lacks comprehensive rebuild contract testing for property changes that may trigger rebuilds. According to the guidelines, tests should verify whether property changes trigger rebuilds or preserve the widget tree using `collect_widget_ids()`, `assert_rebuild_occurred()`, or `assert_no_rebuild()` helpers. The current tests only verify property values (size_hint_y, auto_size_height, strict_label_mode) without checking whether the widget tree was rebuilt or preserved.

## test_advanced_compatibility.py

- Line 689-708: Test method `test_halign_updates_value` does not verify rebuild contract behavior. According to the rebuild contract testing guidelines, tests for style-only property changes should verify that the widget tree is preserved (no rebuild occurs) using `collect_widget_ids()` to compare widget IDs before and after the change. The current test only verifies that the value was updated on existing widgets without checking whether the widget tree was preserved.
- Line 716-735: Test method `test_valign_updates_value` does not verify rebuild contract behavior. According to the rebuild contract testing guidelines, tests for style-only property changes should verify that the widget tree is preserved (no rebuild occurs) using `collect_widget_ids()` to compare widget IDs before and after the change. The current test only verifies that the value was updated on existing widgets without checking whether the widget tree was preserved.
- Line 834-852: Test method `test_rebuild_preserves_content_structure` name does not accurately reflect what it asserts. The method only checks that the number of children is preserved (children count), not the full content structure. A more accurate name would be `test_rebuild_preserves_children_count` or `test_rebuild_preserves_widget_count`.
- Line 155-181, 187-213, 359-408, 768-789, 858-879, 885-906: Rebuild tests manually collect and compare widget IDs using `collect_widget_ids()` and direct comparison instead of using `assert_rebuild_occurred()` or `assert_no_rebuild()` helpers from `test_utils.py`. While the guidelines provide examples of manual rebuild testing, they also provide helper functions for rebuild contract testing. Using these helpers would make the tests more consistent and maintainable. The affected tests are: `test_font_kerning_change_triggers_rebuild`, `test_font_blended_change_triggers_rebuild`, `test_disabled_change_triggers_rebuild`, `test_strip_updates_value`, `test_font_kerning_updates_value`, and `test_font_blended_updates_value`.

## test_serialization.py

- Line 27-77: Custom helper methods `_normalize_ast` and `_merge_adjacent_text` defined in test class instead of in `test_utils.py`. The guidelines state: "When adding new helper functions: 1. **Add to `test_utils.py`** - Never duplicate in individual test files" and "Always use helper functions from `test_utils.py` instead of duplicating code."
- Line 613-620: The strategy combining `st.text(min_size=0, max_size=200)` and `st.text(alphabet=st.characters(whitelist_categories=('L', 'N')), min_size=0, max_size=20)` is classified as "Combination strategy: 20 examples (adequate coverage)". This is actually a combination of two complex/infinite strategies, not finite strategies. According to the guidelines, "Combination strategy" classification is for combining finite strategies where the product can be calculated. This should be classified as "Complex strategy" with rationale about combining two complex text generation strategies.
- Line 550-551: Strategy `st.text(min_size=0, max_size=200)` is classified as "Complex strategy: 30 examples (adequate coverage)". While the classification is correct, the max_examples value of 30 for a text strategy with max_size=200 could be optimized. The guidelines suggest 10-50 examples for complex strategies based on complexity, so 30 is within the acceptable range.
- Line 24-422: Class `TestMarkdownRoundTripSerialization` follows the "one class per property/behavior" guideline with descriptive class name and related test methods grouped together. This is compliant.
- Line 424-545: Class `TestCodeBlockSerialization` follows the "one class per property/behavior" guideline with descriptive class name and related test methods grouped together. This is compliant.
- Line 547-678: Class `TestCodeFenceCollisionProperty` follows the "one class per property/behavior" guideline with descriptive class name and related test methods grouped together. This is compliant.
- Line 681-746: Class `TestMarkdownSerializerEdgeCases` follows the "one class per property/behavior" guideline with descriptive class name and related test methods grouped together. This is compliant.
- Line 14-21: The test file correctly imports helper functions from `test_utils.py` including `markdown_heading`, `markdown_paragraph`, `markdown_bold`, `markdown_italic`, `markdown_link`, and `simple_markdown_document`. This follows the guideline to use shared helper functions instead of duplicating code.
- Line 120-122, 139-141, 162-164, 178-180, 194-196, 210-212: All property-based tests using strategies from test_utils.py are correctly classified with max_examples=20 and standardized comments following the format `# [Strategy Type] strategy: [N] examples ([Rationale])`. This is compliant.

## test_performance.py

- Line 30-33: Strategy combining two `st_font_size(min_value=10, max_value=50)` calls is classified as "Combination strategy: 20 examples (adequate coverage)" but these are complex/infinite strategies (continuous float ranges), not finite strategies. The guidelines state that "Combination strategy" classification is for combining finite strategies where the product can be calculated. This should be classified as "Complex strategy" with rationale about testing font size changes with different initial and new values.
- Line 55-57: Strategy `st_rgba_color()` is classified as "Combination strategy: 20 examples (adequate coverage)" but this is actually a complex/infinite strategy (continuous RGBA color space), not a finite strategy. The classification should be "Complex strategy" with rationale about testing color changes across the RGBA color space.
- Line 77-79: Strategy `st_rgba_color()` is classified as "Combination strategy: 20 examples (adequate coverage)" but this is actually a complex/infinite strategy (continuous RGBA color space), not a finite strategy. The classification should be "Complex strategy" with rationale about testing color changes across the RGBA color space.
- Line 174-176: Strategy `st.floats(min_value=0.5, max_value=3.0, allow_nan=False, allow_infinity=False)` is classified as "Complex strategy: 20 examples (adequate coverage)" which is correct and compliant with the guidelines.
- Line 196-198: Strategy `st.floats(min_value=0.5, max_value=3.0, allow_nan=False, allow_infinity=False)` is classified as "Complex strategy: 20 examples (adequate coverage)" which is correct and compliant with the guidelines.
- Line 216-218: Strategy `st.booleans()` is classified as "Boolean strategy: 2 examples (True/False coverage)" which is correct and compliant with the guidelines.
- Line 279-287: Strategy combining `st_font_size()`, `st_rgba_color()`, `st.sampled_from(['left', 'center', 'right'])`, `st.sampled_from(['top', 'middle', 'bottom'])`, and `st.floats()` is classified as "Combination strategy: 20 examples (adequate coverage)" but this combines complex/infinite strategies with finite strategies. The guidelines state that "Combination strategy" is for combining finite strategies. This should be classified as "Complex strategy" with rationale about testing multiple style changes with various combinations.
- Line 312-317: Strategy combining two `st_rgba_color()` calls is classified as "Complex strategy: 20 examples (adequate coverage)" which is correct and compliant with the guidelines.
- Line 98-116: Tests using `@pytest.mark.parametrize` for small finite enumerations (4 halign values, 3 valign values) are appropriate according to the guidelines which state "Single dimension, small set: Use `@pytest.mark.parametrize`" for enumerations ≤10 values. These are compliant.
- Line 238-277: Tests `test_text_structure_property_rebuilds_tree` and `test_font_name_structure_property_rebuilds_tree` correctly use `force_rebuild()` after property changes to ensure immediate synchronous updates for deterministic testing. This follows the rebuild contract testing guidelines.
- Line 22-352: Class `TestStyleOnlyPropertyUpdates` follows the "one class per property/behavior" guideline with descriptive class name and related test methods grouped together. This is compliant.
- Line 13-18: The test file correctly imports helper functions from `test_utils.py` including `find_labels_recursive`, `collect_widget_ids`, `st_font_size`, and `st_rgba_color`. This follows the guideline to use shared helper functions instead of duplicating code.

## test_rebuild_scheduling.py

No deviations found.

## test_rebuild_semantics.py

- Line 245-256: Strategy combining `simple_markdown_document()` (complex), `st_font_size()` (complex), `st_rgba_color()` (complex), `st.sampled_from(['left', 'center', 'right', 'justify'])` (4 values), `st.sampled_from(['bottom', 'middle', 'top'])` (3 values), `st.booleans()` (2 values), `st_rgba_color()` (complex), `st.sampled_from([None, 'ltr', 'rtl', 'weak_ltr', 'weak_rtl'])` (5 values), and `st.floats()` (complex) is classified as "Combination strategy: 50 examples (combination coverage)". This is incorrect. The guidelines state: "Combination strategy classification is for combining finite strategies where the product can be calculated." This test combines complex/infinite strategies with finite strategies, so it should be classified as "Complex strategy" with rationale about testing multiple style properties with various combinations.
- Line 257-258: The comment "# Combination strategy: 50 examples (combination coverage)" should be "# Complex strategy: 50 examples (testing multiple style properties with various combinations)" to accurately reflect the strategy type.
- Line 420-428: Strategy combining `simple_markdown_document()` (complex), `st_rgba_color()` (complex), `st.sampled_from(['left', 'center', 'right', 'justify'])` (4 values), `st.sampled_from(['bottom', 'middle', 'top'])` (3 values), `st.floats()` (complex), and `st.sampled_from([None, 'ltr', 'rtl', 'weak_ltr', 'weak_rtl'])` (5 values) is classified as "Combination strategy: 50 examples (combination coverage)". This is incorrect. This test combines complex/infinite strategies with finite strategies, so it should be classified as "Complex strategy" with rationale about testing style property propagation with various combinations.
- Line 429-430: The comment "# Combination strategy: 50 examples (combination coverage)" should be "# Complex strategy: 50 examples (testing style property propagation with various combinations)" to accurately reflect the strategy type.
- Line 652-655: Strategy combining two `simple_markdown_document()` calls (both complex) is classified as "Combination strategy: 50 examples (performance optimized)". While this is technically correct (it's a combination of two strategies), the guidelines suggest that "Combination strategy" is for combining finite strategies. Since both strategies are complex/infinite, this should be classified as "Complex strategy" with rationale about testing text changes with various markdown documents.
- Line 656-657: The comment "# Combination strategy: 50 examples (performance optimized)" should be "# Complex strategy: 50 examples (testing text changes with various markdown documents)" to accurately reflect the strategy type.
- Line 695-698: Strategy combining `simple_markdown_document()` (complex) and `st_font_name()` (3 values) is classified as "Small finite strategy: 3 examples (input space size: 3)". This is incorrect. The guidelines state: "Small finite strategy" is for small integer ranges (≤10 values) or small sampled_from lists. This test combines a complex/infinite strategy with a finite strategy, so it should be classified as "Complex strategy" with rationale about testing font_name changes with various markdown documents.
- Line 699-700: The comment "# Small finite strategy: 3 examples (input space size: 3)" should be "# Complex strategy: 3 examples (testing font_name changes with various markdown documents)" to accurately reflect the strategy type.
- Line 737-740: Strategy combining `simple_markdown_document()` (complex) and `st.sampled_from(['unstyled', 'styled'])` (2 values) is classified as "Small finite strategy: 2 examples (input space size: 2)". This is incorrect. This test combines a complex/infinite strategy with a finite strategy, so it should be classified as "Complex strategy" with rationale about testing link_style changes with various markdown documents.
- Line 741-742: The comment "# Small finite strategy: 2 examples (input space size: 2)" should be "# Complex strategy: 2 examples (testing link_style changes with various markdown documents)" to accurately reflect the strategy type.
- Line 784-794: Strategy combining `simple_markdown_document()` (complex), `st_font_size()` (complex), `st_rgba_color()` (complex), `st.sampled_from(['left', 'center', 'right', 'justify'])` (4 values), `st.sampled_from(['bottom', 'middle', 'top'])` (3 values), `st.floats()` (complex), and `st.booleans()` (2 values) is classified as "Combination strategy: 50 examples (combination coverage)". This is incorrect. This test combines complex/infinite strategies with finite strategies, so it should be classified as "Complex strategy" with rationale about testing root ID preservation across style property changes with various combinations.
- Line 795-796: The comment "# Combination strategy: 50 examples (combination coverage)" should be "# Complex strategy: 50 examples (testing root ID preservation across style property changes with various combinations)" to accurately reflect the strategy type.
- Line 829-836: Strategy combining `simple_markdown_document()` (complex), `st_font_name()` (3 values), `st.sampled_from(['unstyled', 'styled'])` (2 values), `st.booleans()` (2 values), and `st.sampled_from(['widgets', 'auto'])` (2 values) is classified as "Combination strategy: 50 examples (combination coverage)". This is incorrect. This test combines complex/infinite strategies with finite strategies, so it should be classified as "Complex strategy" with rationale about testing root ID preservation across structure property changes with various combinations.
- Line 837-838: The comment "# Combination strategy: 50 examples (combination coverage)" should be "# Complex strategy: 50 examples (testing root ID preservation across structure property changes with various combinations)" to accurately reflect the strategy type.
- Line 872-879: Strategy combining `simple_markdown_document()` (complex), `st_font_size()` (complex), `st_rgba_color()` (complex), `st_font_name()` (3 values), and `st.sampled_from(['unstyled', 'styled'])` (2 values) is classified as "Combination strategy: 50 examples (combination coverage)". This is incorrect. This test combines complex/infinite strategies with finite strategies, so it should be classified as "Complex strategy" with rationale about testing root ID preservation across mixed property changes with various combinations.
- Line 880-881: The comment "# Combination strategy: 50 examples (combination coverage)" should be "# Complex strategy: 50 examples (testing root ID preservation across mixed property changes with various combinations)" to accurately reflect the strategy type.
- Line 503-525, 526-548, 549-571, 572-596, 598-620, 621-643: Rebuild tests manually collect and compare widget IDs using `collect_widget_ids()` and direct comparison instead of using `assert_rebuild_occurred()` or `assert_no_rebuild()` helpers from `test_utils.py`. The guidelines provide these helper functions for rebuild contract testing: "Use these helper functions from `test_utils.py`: `def assert_rebuild_occurred(widget, change_func):` and `def assert_no_rebuild(widget, change_func):`". The affected tests are: `test_text_change_triggers_rebuild`, `test_font_name_change_triggers_rebuild`, `test_text_size_change_triggers_rebuild`, `test_link_style_change_triggers_rebuild`, `test_strict_label_mode_change_triggers_rebuild`, and `test_render_mode_change_triggers_rebuild`.
- Line 88-101, 103-116, 118-131, 133-146, 148-161, 163-179, 181-194, 196-209: Style property preservation tests manually collect and compare widget IDs using `collect_widget_ids()` and direct comparison instead of using `assert_no_rebuild()` helper from `test_utils.py`. The guidelines provide this helper function for verifying no rebuild occurred. The affected tests are: `test_base_font_size_preserves_widget_tree`, `test_color_preserves_widget_tree`, `test_halign_preserves_widget_tree`, `test_valign_preserves_widget_tree`, `test_disabled_preserves_widget_tree`, `test_disabled_color_preserves_widget_tree`, `test_base_direction_preserves_widget_tree`, and `test_line_height_preserves_widget_tree`.
- Line 15-24: The test file correctly imports helper functions from `test_utils.py` including `simple_markdown_document`, `find_labels_recursive`, `colors_equal`, `floats_equal`, `collect_widget_ids`, `st_font_size`, `st_font_name`, and `st_rgba_color`. This follows the guideline to use shared helper functions instead of duplicating code.
- Line 51-77, 79-238, 240-301, 303-411, 413-491, 493-643, 645-778, 780-910: All test classes follow the "one class per property/behavior" guideline with descriptive class names and related test methods grouped together. This is compliant.
- Line 257-258, 429-430, 656-657, 699-700, 741-742, 795-796, 837-838, 880-881: All property-based tests have standardized comments following the format `# [Strategy Type] strategy: [N] examples ([Rationale])`, though some strategy types are incorrectly classified. The comment format itself is compliant.
- Line 88-238, 503-643: Tests correctly use `force_rebuild()` after structure property changes to ensure immediate synchronous updates for deterministic testing. This follows the rebuild contract testing guidelines.

## test_clipping_behavior.py

No deviations found.

## test_rtl_alignment.py

No deviations found.

## test_shortening_and_coordinate.py

- Line 331: Test method `test_shorten_change_updates_value` name does not accurately reflect what it asserts. The method name suggests it only tests value updates, but the actual implementation tests that changing the `shorten` property triggers a rebuild (via `force_rebuild()`) and verifies the new value is applied. According to the rebuild contract testing guidelines, tests that verify rebuild behavior should use names like `test_*_triggers_rebuild_*` or `test_*_rebuilds_*`. A more accurate name would be `test_shorten_change_triggers_rebuild_with_new_value` or `test_shorten_change_rebuilds_with_new_value`.

## test_texture_render_mode.py

- Line 26: Unused import `find_labels_recursive` is imported from test_utils.py but never used in the file. The guidelines emphasize using shared helper functions, but importing unused functions creates unnecessary dependencies.
- Line 216-231: Strategy combining `st.tuples(st.floats(...), st.floats(...), st.floats(...), st.floats(...))`, `st.from_regex(...)`, and `st.floats(...)` is classified as "Combination strategy: 50 examples (combination coverage)". However, these are all complex/infinite strategies (continuous float ranges and regex patterns), not finite strategies. According to the guidelines, "Combination strategy" classification is for combining finite strategies where the product can be calculated. This should be classified as "Complex strategy: 50 examples (testing zone coordinates, ref names, and touch offsets)" to accurately reflect the strategy type.
- Line 319-333: Strategy combining `st.tuples(st.floats(...), st.floats(...), st.floats(...), st.floats(...))`, `st.from_regex(...)`, and `st.floats(...)` is classified as "Combination strategy: 50 examples (combination coverage)". Similar to the previous issue, these are all complex/infinite strategies, not finite strategies. This should be classified as "Complex strategy: 50 examples (testing zone coordinates, ref names, and outside offsets)" to accurately reflect the strategy type.

## test_texture_sizing.py

- Line 28-356: Class `TestComprehensiveTextureSizeCalculation` contains tests for multiple distinct texture_size behaviors (return type, non-negative values, empty labels, heading widgets, paragraph widgets, code blocks, lists, tables, block quotes, thematic breaks, content height, mixed content, accessibility, nested lists, ordered lists, text changes, images, heading levels, blank lines). According to the guideline "One class per property or behavior", these should be split into separate classes like `TestTextureSizeReturnType`, `TestTextureSizeNonNegative`, `TestEmptyLabelTextureSize`, `TestHeadingTextureSize`, `TestParagraphTextureSize`, `TestCodeBlockTextureSize`, `TestListTextureSize`, `TestTableTextureSize`, `TestBlockQuoteTextureSize`, `TestThematicBreakTextureSize`, `TestContentHeightTextureSize`, `TestMixedContentTextureSize`, `TestTextureSizeAccessibility`, `TestNestedListTextureSize`, `TestOrderedListTextureSize`, `TestTextureSizeTextChanges`, `TestImageTextureSize`, `TestHeadingLevelsTextureSize`, `TestBlankLinesTextureSize` for better organization and clarity.
- Line 269-293: Test method `test_texture_size_updates_on_text_change` uses `force_rebuild()` after text property changes but does not verify that a rebuild occurred. According to the rebuild contract testing guidelines, tests for structure property changes should verify that the widget tree was rebuilt using `collect_widget_ids()` to compare widget IDs before and after the change, or use `assert_rebuild_occurred()` helper from test_utils.py. The current test only verifies that texture_size returns valid values without checking whether the widget tree was actually rebuilt.
