## test_advanced_compatibility.py
- Line 877: Test method name `test_disabled_color_updates_value` suggests a value update test, but the implementation verifies rebuild behavior (calls `force_rebuild()`). According to testing guidelines, value update tests should not verify rebuilds and rebuild tests should use naming convention `test_*_triggers_rebuild_*` or `test_*_rebuilds_*`. The test should be renamed to `test_disabled_change_triggers_rebuild` to match its actual behavior.

## test_helper_availability.py
- Line 59: Comment says "Combination strategy: 10 examples (combination coverage)" but `color_strategy` is a complex/infinite strategy, not a finite combination strategy. According to testing guidelines (lines 363-377), combination strategies are for finite strategies where the product size can be calculated. This should be classified as "Complex strategy" instead.
- Line 75: Comment says "Combination strategy: 10 examples (combination coverage)" but `text_padding_strategy` is a complex/infinite strategy, not a finite combination strategy. According to testing guidelines (lines 363-377), combination strategies are for finite strategies where the product size can be calculated. This should be classified as "Complex strategy" instead.
- Line 91: Comment says "Combination strategy: 10 examples (combination coverage)" but `st.floats(min_value=-1000, max_value=1000, allow_nan=False, allow_infinity=False)` is a complex/infinite strategy (large range with 2000+ possible values). According to testing guidelines (lines 363-377), combination strategies are for finite strategies where the product size can be calculated. This should be classified as "Complex strategy" instead.
- Line 146: Comment says "Complex strategy: 1 example (adequate coverage)" - Using `max_examples=1` for a complex strategy is unusual. According to testing guidelines (lines 379-391), complex strategies should use 10-50 examples based on complexity. While testing strategy availability might justify fewer examples, the rationale "adequate coverage" is too vague and should be more specific about why 1 example is sufficient for this particular test.
- Line 159: Comment says "Complex strategy: 1 example (adequate coverage)" - Same issue as line 146. Using `max_examples=1` for a complex strategy with vague rationale violates the guideline that complex strategies should use 10-50 examples.
- Line 172: Comment says "Complex strategy: 1 example (adequate coverage)" - Same issue as line 146. Using `max_examples=1` for a complex strategy with vague rationale violates the guideline that complex strategies should use 10-50 examples.

## test_padding_properties.py
- Line 119-121: Test `test_default_padding_is_zero` uses `@given(st.data())` but the `data` parameter is never used in the test body. The test simply verifies that default padding is zero, which is a concrete assertion that doesn't require property-based testing. According to testing guidelines (lines 276-300), property-based tests should be used for universal properties, not for testing specific default values. This should be a regular unit test without the `@given` decorator.
- Line 238: Test method name `test_padding_change_updates_value` suggests a value update test, but the implementation calls `label.force_rebuild()` which indicates rebuild behavior. According to testing guidelines (lines 102-138), tests that verify rebuild behavior should use naming convention `test_*_triggers_rebuild_*` or `test_*_rebuilds_*`, while value update tests should not call rebuild methods. The test should either be renamed to `test_padding_change_triggers_rebuild` and verify rebuild occurred using `assert_rebuild_occurred()`, or remove the `force_rebuild()` call if it's only testing value updates.
- Line 283: Test method name `test_padding_update_paragraph` suggests a value update test, but the implementation calls `label.force_rebuild()` without verifying rebuild behavior. According to testing guidelines, value update tests should not call rebuild methods. If the test needs to verify rebuild behavior, it should be renamed to `test_padding_update_triggers_rebuild` and use `assert_rebuild_occurred()` to verify the rebuild actually occurred.
- Line 308: Test method name `test_padding_update_complex_content` suggests a value update test, but the implementation calls `label.force_rebuild()` without verifying rebuild behavior. Same issue as line 283 - either remove the rebuild call if testing value updates, or rename to `test_padding_update_triggers_rebuild` and verify rebuild occurred.
- Line 11-14: Unused imports - `BoxLayout`, `Label`, `Widget`, and `GridLayout` from kivy.uix modules are imported but never used in the test file. According to best practices (line 628), unused imports should be removed to keep the code clean.
- Line 251: Test `test_padding_change_updates_value` calls `label.force_rebuild()` after changing the padding property. According to testing guidelines (lines 186-258), tests should verify rebuild behavior using helper functions like `assert_rebuild_occurred()` or `assert_no_rebuild()` instead of manually calling `force_rebuild()`. The test should collect widget IDs before and after the change to verify whether a rebuild actually occurs, rather than forcing one.
- Line 297: Test `test_padding_update_paragraph` calls `label.force_rebuild()` after changing the padding property. Same issue as line 251 - the test should use rebuild detection helpers to verify rebuild behavior instead of forcing a rebuild.
- Line 335: Test `test_padding_update_complex_content` calls `label.force_rebuild()` after changing the padding property. Same issue as line 251 - the test should use rebuild detection helpers to verify rebuild behavior instead of forcing a rebuild.
- Line 353: Test `test_multiple_padding_updates` calls `label.force_rebuild()` in a loop after each padding change. Same issue as line 251 - the test should use rebuild detection helpers to verify rebuild behavior instead of forcing a rebuild.
- Line 9: The `assume` function is imported from hypothesis but is only used in one test (line 103, 240, 285, 310, 623, 720). While this is not a violation, it's worth noting that `assume()` is being used correctly to filter invalid inputs in property tests as per guidelines (line 644).

## test_rtl_alignment.py
- Line 8: Unused import `os` - The `import os` statement is declared but never used anywhere in the file. According to best practices (TESTING.md line 628), unused imports should be removed to keep the code clean.

## test_strategy_classification.py
- Line 24-26: Test `test_boolean_strategy_classification` uses `st.just('st.booleans()')` which generates only 1 example, but the comment says "Small finite strategy: 1 examples (input space size: 1)". According to TESTING.md guidelines, boolean strategies should use exactly 2 examples (True/False coverage). The comment format should be "Boolean strategy: 2 examples (True/False coverage)" for boolean strategies, and the max_examples should be 2, not 1.
- Line 53-55: Test `test_small_sampled_from_classification` uses `st.lists(st.text(min_size=1, max_size=3, alphabet='abc'), min_size=1, max_size=10)` which generates lists with potentially infinite combinations (any combination of strings). The comment says "Medium finite strategy: 10 examples (adequate finite coverage)". According to TESTING.md guidelines (lines 379-391), `st.lists()` with `st.text()` is a complex/infinite strategy, not a finite strategy. The comment should say "Complex strategy: 10 examples (adequate coverage)".
- Line 126-128: Test `test_sampled_from_uses_list_length` uses `st.lists(st.text(min_size=1, max_size=2, alphabet='ab'), min_size=1, max_size=10)` which generates lists with potentially infinite combinations. The comment says "Complex strategy: 10 examples (adequate coverage)" which is correct for the strategy type, but the test is about sampled_from classification, not about the lists strategy itself. This creates confusion about what is actually being tested.

## test_assertion_analyzer.py
- Line 22: Class `TestAssertionAnalyzer` has a generic docstring "Unit tests for AssertionAnalyzer." According to TESTING.md guidelines (lines 45-74), class docstrings should clearly indicate what is being tested. Examples show docstrings like "Tests for [specific behavior]." Consider a more specific docstring like "Tests for assertion pattern detection and naming mismatch analysis."
- Lines 89-128: Property-based test `test_value_change_test_naming_property` is at module level rather than within a class. According to TESTING.md guidelines (lines 43-74), tests should be organized into logical classes with descriptive names. The guidelines explicitly state "Related test methods grouped within the same class." This test should be moved into the `TestAssertionAnalyzer` class.
- Lines 131-174: Property-based test `test_assertion_classification_consistency` is at module level rather than within a class. According to TESTING.md guidelines (lines 43-74), tests should be organized into logical classes with descriptive names. This test should be moved into the `TestAssertionAnalyzer` class.
- Lines 177-229: Integration test `test_file_analysis_integration()` is a module-level function instead of being in a class. According to TESTING.md guidelines (lines 43-74), tests should be organized into logical classes. Consider creating a new class like `TestAssertionAnalyzerIntegration` to group these integration tests.
