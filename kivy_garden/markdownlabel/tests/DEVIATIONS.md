## test_comment_format.py
- Line 538: Comment says "Complex strategy: 30 examples (adequate coverage)" but the test uses `st.sampled_from()` to sample from 3 independent domains: strategy_type (5 values), max_examples (1000 values), and rationale_base (5 values). This creates a combination of multiple sampled strategies. According to TESTING.md guidelines (lines 363-377), when multiple strategies are combined (even with a single @given), this should be classified as a "Combination strategy" not a "Complex strategy". The comment should say "Combination strategy: 30 examples (performance optimized)" or similar to accurately reflect the strategy type.

## test_text_properties.py
- Line 162-164: Test `test_valign_forwarded_with_height` uses a combination of `st.floats()` and `st.sampled_from()` strategies, but the comment says "Small finite strategy: 3 examples (input space size: 3)". According to TESTING.md guidelines (lines 363-377), combination strategies are for multiple strategies combined (tuples, multiple @given arguments). This is a combination strategy, not a small finite strategy. The comment should say "Combination strategy" instead of "Small finite strategy".

## test_documentation_compliance.py
- Line 123-137: Test method `test_custom_value_detection_property` has a docstring "Property test for custom value detection logic." which is generic and does not describe what specific property is being tested or what behavior is expected. According to TESTING.md guidelines (lines 45-74), test docstrings should clearly describe what is being tested, including what property or behavior is being verified and what the expected outcome is.
- Line 138-164: Test method `test_comment_detection_property` has a docstring "Property test for explanatory comment detection." which is generic and does not describe what specific property is being tested or what behavior is expected. According to TESTING.md guidelines, test docstrings should provide specific details about the test's purpose and expected outcomes.

## test_advanced_compatibility.py
- Line 877: Test method name `test_disabled_color_updates_value` suggests a value update test, but the implementation verifies rebuild behavior (calls `force_rebuild()`). According to testing guidelines, value update tests should not verify rebuilds and rebuild tests should use naming convention `test_*_triggers_rebuild_*` or `test_*_rebuilds_*`. The test should be renamed to `test_disabled_change_triggers_rebuild` to match its actual behavior.

## test_helper_availability.py
- Line 59: Comment says "Combination strategy: 10 examples (combination coverage)" but `color_strategy` is a complex/infinite strategy, not a finite combination strategy. According to testing guidelines (lines 363-377), combination strategies are for finite strategies where the product size can be calculated. This should be classified as "Complex strategy" instead.
- Line 75: Comment says "Combination strategy: 10 examples (combination coverage)" but `text_padding_strategy` is a complex/infinite strategy, not a finite combination strategy. According to testing guidelines (lines 363-377), combination strategies are for finite strategies where the product size can be calculated. This should be classified as "Complex strategy" instead.
- Line 91: Comment says "Combination strategy: 10 examples (combination coverage)" but `st.floats(min_value=-1000, max_value=1000, allow_nan=False, allow_infinity=False)` is a complex/infinite strategy (large range with 2000+ possible values). According to testing guidelines (lines 363-377), combination strategies are for finite strategies where the product size can be calculated. This should be classified as "Complex strategy" instead.
- Line 146: Comment says "Complex strategy: 1 example (adequate coverage)" - Using `max_examples=1` for a complex strategy is unusual. According to testing guidelines (lines 379-391), complex strategies should use 10-50 examples based on complexity. While testing strategy availability might justify fewer examples, the rationale "adequate coverage" is too vague and should be more specific about why 1 example is sufficient for this particular test.
- Line 159: Comment says "Complex strategy: 1 example (adequate coverage)" - Same issue as line 146. Using `max_examples=1` for a complex strategy with vague rationale violates the guideline that complex strategies should use 10-50 examples.
- Line 172: Comment says "Complex strategy: 1 example (adequate coverage)" - Same issue as line 146. Using `max_examples=1` for a complex strategy with vague rationale violates the guideline that complex strategies should use 10-50 examples.

## test_padding_properties.py
- Line 119-121: Test `test_default_padding_is_zero` uses `@given(st.data())` but the `data` parameter is never used in the test body. The test simply verifies that default padding is zero, which is a concrete assertion that doesn't require property-based testing. According to testing guidelines (lines 276-300), property-based tests should be used for universal properties, not for testing specific default values. This should be a regular unit test without the `@given` decorator.
- Line 238: Test method name `test_padding_change_updates_value` suggests a value update test, but the implementation calls `label.force_rebuild()` which indicates rebuild behavior. According to testing guidelines (lines 102-138), tests that verify rebuild behavior should use naming convention `test_*_triggers_rebuild_*` or `test_*_rebuilds_*`, while value update tests should not call rebuild methods. The test should either be renamed to `test_padding_change_triggers_rebuild` and verify rebuild occurred using `assert_rebuild_occurred()`, or remove the `force_rebuild()` call if it's only testing value updates.
- Line 283: Test method name `test_padding_update_paragraph` suggests a value update test, but the implementation calls `label.force_rebuild()` without verifying rebuild behavior. According to testing guidelines, value update tests should not call rebuild methods. If the test needs to verify rebuild behavior, it should be renamed to `test_padding_update_triggers_rebuild` and use `assert_rebuild_occurred()` to verify the rebuild actually occurred.
- Line 308: Test method name `test_padding_update_complex_content` suggests a value update test, but the implementation calls `label.force_rebuild()` without verifying rebuild behavior. Same issue as line 283 - either remove the rebuild call if testing value updates, or rename to `test_padding_update_triggers_rebuild` and verify rebuild occurred.
- Line 11-14: Unused imports - `BoxLayout`, `Label`, `Widget`, and `GridLayout` from kivy.uix modules are imported but never used in the test file. According to best practices (line 628), unused imports should be removed to keep the code clean.
- Line 251: Test `test_padding_change_updates_value` calls `label.force_rebuild()` after changing the padding property. According to testing guidelines (lines 186-258), tests should verify rebuild behavior using helper functions like `assert_rebuild_occurred()` or `assert_no_rebuild()` instead of manually calling `force_rebuild()`. The test should collect widget IDs before and after the change to verify whether a rebuild actually occurs, rather than forcing one.
- Line 297: Test `test_padding_update_paragraph` calls `label.force_rebuild()` after changing the padding property. Same issue as line 251 - the test should use rebuild detection helpers to verify rebuild behavior instead of forcing a rebuild.
- Line 335: Test `test_padding_update_complex_content` calls `label.force_rebuild()` after changing the padding property. Same issue as line 251 - the test should use rebuild detection helpers to verify rebuild behavior instead of forcing a rebuild.
- Line 353: Test `test_multiple_padding_updates` calls `label.force_rebuild()` in a loop after each padding change. Same issue as line 251 - the test should use rebuild detection helpers to verify rebuild behavior instead of forcing a rebuild.
- Line 9: The `assume` function is imported from hypothesis but is only used in one test (line 103, 240, 285, 310, 623, 720). While this is not a violation, it's worth noting that `assume()` is being used correctly to filter invalid inputs in property tests as per guidelines (line 644).

## test_rtl_alignment.py
- Line 8: Unused import `os` - The `import os` statement is declared but never used anywhere in the file. According to best practices (TESTING.md line 628), unused imports should be removed to keep the code clean.

## test_clipping_behavior.py
- Line 77-78: `test_clipping_container_height_matches_text_size` uses `max_examples=50` for a single `st.floats()` strategy. According to TESTING.md guidelines (lines 379-391), complex strategies like `st.floats()` should typically use 10-20 examples. Using 50 examples is at the upper limit and may be excessive for this simple test case.
- Line 244-245: `test_text_size_width_only_no_clipping` uses `max_examples=50` for a single `st.floats()` strategy. Same issue as line 77-78 - complex strategies should use 10-20 examples for adequate coverage, and 50 examples may be excessive.

## test_strategy_classification.py
- Line 24-26: Test `test_boolean_strategy_classification` uses `st.just('st.booleans()')` which generates only 1 example, but the comment says "Small finite strategy: 1 examples (input space size: 1)". According to TESTING.md guidelines, boolean strategies should use exactly 2 examples (True/False coverage). The comment format should be "Boolean strategy: 2 examples (True/False coverage)" for boolean strategies, and the max_examples should be 2, not 1.
- Line 53-55: Test `test_small_sampled_from_classification` uses `st.lists(st.text(min_size=1, max_size=3, alphabet='abc'), min_size=1, max_size=10)` which generates lists with potentially infinite combinations (any combination of strings). The comment says "Medium finite strategy: 10 examples (adequate finite coverage)". According to TESTING.md guidelines (lines 379-391), `st.lists()` with `st.text()` is a complex/infinite strategy, not a finite strategy. The comment should say "Complex strategy: 10 examples (adequate coverage)".
- Line 126-128: Test `test_sampled_from_uses_list_length` uses `st.lists(st.text(min_size=1, max_size=2, alphabet='ab'), min_size=1, max_size=10)` which generates lists with potentially infinite combinations. The comment says "Complex strategy: 10 examples (adequate coverage)" which is correct for the strategy type, but the test is about sampled_from classification, not about the lists strategy itself. This creates confusion about what is actually being tested.

## test_kivy_renderer.py
- Line 88: Test `test_heading_font_size_scales_with_base` uses `@given(st.integers(min_value=1, max_value=6), st.floats(min_value=10, max_value=30))` which has an input space of 6 values for integers, but `max_examples=5` is set. According to TESTING.md guidelines (lines 335-347), small finite strategies should use the input space size. For integers 1-6, there are 6 values, so `max_examples` should be 6.
- Line 89-90: The comment for `test_heading_font_size_scales_with_base` says "Complex strategy: 10 examples (adequate coverage)" but the actual strategy is a combination of `st.integers(min_value=1, max_value=6)` (6 values) and `st.floats(min_value=10, max_value=30)` (21 values), giving a total input space of 6 Ã— 21 = 126. This is a combination strategy that has been optimized for performance. The comment should say "Combination strategy: 10 examples (performance optimized)" to accurately reflect the strategy type and rationale.

## test_assertion_analyzer.py
- Line 22: Class `TestAssertionAnalyzer` has a generic docstring "Unit tests for AssertionAnalyzer." According to TESTING.md guidelines (lines 45-74), class docstrings should clearly indicate what is being tested. Examples show docstrings like "Tests for [specific behavior]." Consider a more specific docstring like "Tests for assertion pattern detection and naming mismatch analysis."
- Lines 89-128: Property-based test `test_value_change_test_naming_property` is at module level rather than within a class. According to TESTING.md guidelines (lines 43-74), tests should be organized into logical classes with descriptive names. The guidelines explicitly state "Related test methods grouped within the same class." This test should be moved into the `TestAssertionAnalyzer` class.
- Lines 131-174: Property-based test `test_assertion_classification_consistency` is at module level rather than within a class. According to TESTING.md guidelines (lines 43-74), tests should be organized into logical classes with descriptive names. This test should be moved into the `TestAssertionAnalyzer` class.
- Lines 177-229: Integration test `test_file_analysis_integration()` is a module-level function instead of being in a class. According to TESTING.md guidelines (lines 43-74), tests should be organized into logical classes. Consider creating a new class like `TestAssertionAnalyzerIntegration` to group these integration tests.

## test_refactoring_properties.py
- Line 89: Redundant local `import os` statement inside method `test_fast_test_discovery_baseline` when `os` is already imported at module level (line 9). According to TESTING.md best practices (line 628), unused/duplicate code should be removed to keep the code clean.
- Line 137: Redundant local `import os` statement inside method `test_individual_module_discovery_functionality` when `os` is already imported at module level (line 9). According to TESTING.md best practices (line 628), unused/duplicate code should be removed to keep the code clean.
- Line 173: Redundant local `import os` statement inside method `test_discovery_startup_functionality` when `os` is already imported at module level (line 9). According to TESTING.md best practices (line 628), unused/duplicate code should be removed to keep the code clean.

## test_font_properties.py
- Line 9: Unused import `os` - The `import os` statement is declared but never used anywhere in the file. According to best practices (TESTING.md line 628), unused imports should be removed to keep the code clean.

## test_sizing_behavior.py
- Line 11-12: Unused imports `BoxLayout` and `Label` from `kivy.uix` are declared but never used anywhere in the file. According to best practices (TESTING.md line 628), unused imports should be removed to keep the code clean.
- Lines 29, 47, 69, 94, 105, 132, 162, 176, 195, 222, 244, 266, 301, 338, 352, 371, 398, 407, 417, 440, 463, 491, 507, 525, 544: The file uses `@pytest.mark.property` marker extensively, but this marker is NOT documented in TESTING.md. The guidelines only document `@pytest.mark.slow`, `@pytest.mark.needs_window`, and `@pytest.mark.test_tests` markers. Using an undocumented marker violates the principle that test practices should follow documented guidelines.

## test_duplicate_detector.py
- No deviations found. The test file follows all testing guidelines:
  - Proper module docstring and class organization
  - Correct pytest marker usage (`@pytest.mark.test_tests`)
  - Descriptive test method names
  - Proper property-based test comment formats (e.g., "Complex strategy: 20 examples (adequate coverage)" and "Small finite strategy: 5 examples (input space size: 5)")
  - Appropriate max_examples values based on strategy type
  - Descriptive test docstrings
  - Proper cleanup in try/finally blocks

## test_inline_renderer.py
- Lines 61-74: The `link_token()` strategy uses `st.sampled_from()` with 69 URL-safe characters combined with `st.text()` for URL generation. This creates a combination of strategies (sampled_from + text). According to TESTING.md guidelines (lines 363-377), when multiple strategies are combined, this should be classified as a "Combination strategy" not a "Complex strategy". The comment should say "Combination strategy: 20 examples (combination coverage)" instead of "Complex strategy: 20 examples (adequate coverage)".
- Lines 408-420: The `test_urls_with_brackets_are_safe` test uses `st.one_of()` with 5 different mapped text strategies. According to TESTING.md guidelines (lines 363-377), this is a combination strategy (multiple alternative strategies combined with one_of). The comment should say "Combination strategy: 20 examples (combination coverage)" instead of "Complex strategy: 20 examples (adequate coverage)".
- Lines 658-677: The `test_html_content_is_escaped` test uses `st.one_of()` with 8 different mapped text strategies. According to TESTING.md guidelines (lines 363-377), this is a combination strategy (multiple alternative strategies combined with one_of). The comment should say "Combination strategy: 20 examples (combination coverage)" instead of "Complex strategy: 20 examples (adequate coverage)".

## test_shared_infrastructure.py
- Line 37-41: Test `test_markdown_heading_strategy_generates_valid_headings` has an overly verbose docstring with markdown formatting (Feature/Property/Rationale sections). According to TESTING.md guidelines (lines 286-300, 456-490), test docstrings should be concise and descriptive, like "Test that [property] holds for all valid inputs" or "Verify [specific behavior]". The docstring format "**Feature: ...**\n*For any* ..." with markdown headers is overly complex and not aligned with the guideline examples.
- Line 160-165: Test `test_find_labels_recursive_function_available` has an overly verbose docstring with markdown formatting (Feature/Property/Rationale sections). Same issue as line 37-41 - the docstring uses "**Feature: ...**\n*For any* ..." with markdown headers, which is overly complex and not aligned with the guideline examples for test docstrings.
